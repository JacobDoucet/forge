{{- $object := .Object }}
import { useCallback, useMemo, useState, useEffect } from 'react';
import { Autocomplete, TextField } from '@mui/material';
import { {{ UCC $object.Name }}Projection, {{ UCC .Name }}SortParams } from '../../model/{{ GetObjModelFilename $object }}';
import { {{ UCC $object.Name }}WithRefs } from '../../model/{{ GetObjApiFilename $object }}';
import { useSearch{{ UCC $object.Name }}s } from '../tanstack-query/{{ KC .Name }}-queries';
{{- range ListRefFieldObjects $object }}
 {{- if not (eq .Name $object.Name) }}
import { {{ UCC .Name }} } from '../../model/{{ GetObjModelFilename . }}';
import { useSearch{{ UCC .Name }}s } from '../tanstack-query/{{ KC .Name }}-queries';
    {{- end }}
{{- end }}

export type {{ UCC $object.Name }}SearchSelectorOptions = {
    label?: string;
    placeholder?: string;
    multiple?: boolean;
    disabled?: boolean;
    clearable?: boolean;
    searchProjection?: {{ UCC $object.Name }}Projection;
    defaultSort?: {{ UCC .Name }}SortParams;
    getOptionLabel: (option: {{ UCC $object.Name }}WithRefs) => string;
    getOptionDescription?: (option: {{ UCC $object.Name }}WithRefs) => string;
    isOptionEqualToValue?: (option: {{ UCC $object.Name }}WithRefs, value: {{ UCC $object.Name }}WithRefs) => boolean;
    filterOptions?: (options: {{ UCC $object.Name }}WithRefs[], state: any) => {{ UCC $object.Name }}WithRefs[];
    searchQuery?: object;
    enableSearch?: boolean;
    searchDebounceMs?: number;
    maxOptions?: number;
};

export type {{ UCC $object.Name }}SearchSelectorProps = {{ UCC $object.Name }}SearchSelectorOptions & {
    value?: {{ UCC $object.Name }}WithRefs | {{ UCC $object.Name }}WithRefs[] | null;
    onChange: (value: {{ UCC $object.Name }}WithRefs | {{ UCC $object.Name }}WithRefs[] | null) => void;
    onInputChange?: (inputValue: string) => void;
};

export function use{{ UCC $object.Name }}SearchSelector(options: {{ UCC $object.Name }}SearchSelectorOptions) {
    const [inputValue, setInputValue] = useState('');
    const [searchQuery, setSearchQuery] = useState(() => options.searchQuery || {});

    // Debounced search effect
    const debouncedInputValue = useDebounce(inputValue, options.searchDebounceMs || 300);

    // Update search query when input changes (if search is enabled)
    useEffect(() => {
        if (!options.enableSearch || !debouncedInputValue.trim()) {
            setSearchQuery(options.searchQuery || {});
            return;
        }

        // Create a text search query - this would depend on your backend implementation
        // For now, assuming there's a text search field or similar
        const textSearchQuery = {
            ...options.searchQuery,
            // Add text search logic here based on your backend API
            // Example: textSearch: debouncedInputValue
        };
        
        setSearchQuery(textSearchQuery);
    }, [debouncedInputValue, options.searchQuery, options.enableSearch]);

    // Fetch data
    const { data: searchResults, isLoading, error } = useSearch{{ UCC $object.Name }}s({
        query: searchQuery,
        projection: options.searchProjection || { id: true },
        sort: options.defaultSort,
        limit: options.maxOptions || 100,
    });

    const options_data = useMemo(() => {
        return searchResults?.data || [];
    }, [searchResults?.data]);

    const autocompleteProps = useMemo(() => ({
        options: options_data,
        loading: isLoading,
        multiple: options.multiple || false,
        disabled: options.disabled || false,
        disableClearable: !(options.clearable ?? true),
        getOptionLabel: options.getOptionLabel,
        isOptionEqualToValue: options.isOptionEqualToValue || ((option, value) => option.{{ LCC $object.Name }}.id === value.{{ LCC $object.Name }}.id),
        filterOptions: options.filterOptions || ((opts, state) => {
            // If search is enabled, don't filter client-side (server handles it)
            if (options.enableSearch) {
                return opts;
            }
            // Default MUI filtering
            return opts.filter(opt => 
                options.getOptionLabel(opt).toLowerCase().includes(state.inputValue.toLowerCase())
            );
        }),
    }), [options_data, isLoading, options]);

    return {
        autocompleteProps,
        inputValue,
        setInputValue,
        searchResults,
        isLoading,
        error,
        options: options_data,
    };
}

export type Use{{ UCC $object.Name }}SearchSelectorResult = {
    autocompleteProps: ReturnType<typeof use{{ UCC $object.Name }}SearchSelector>['autocompleteProps'];
    inputValue: string;
    setInputValue: (value: string) => void;
    searchResults: ReturnType<typeof useSearch{{ UCC $object.Name }}s>['data'];
    isLoading: boolean;
    error: ReturnType<typeof useSearch{{ UCC $object.Name }}s>['error'];
    options: {{ UCC $object.Name }}WithRefs[];
};

// Simple debounce hook
function useDebounce<T>(value: T, delay: number): T {
    const [debouncedValue, setDebouncedValue] = useState<T>(value);

    useEffect(() => {
        const handler = setTimeout(() => {
            setDebouncedValue(value);
        }, delay);

        return () => {
            clearTimeout(handler);
        };
    }, [value, delay]);

    return debouncedValue;
}

// Preset configurations for common use cases
export function use{{ UCC $object.Name }}SearchSelectorPresets() {
    return {
        // Basic selector with minimal data
        minimal: (): {{ UCC $object.Name }}SearchSelectorOptions => ({
            searchProjection: { id: true },
            getOptionLabel: (option) => option.{{ LCC $object.Name }}.id,
            enableSearch: false,
        }),

        // Full-featured selector with search
        searchable: (searchProjection?: {{ UCC $object.Name }}Projection): {{ UCC $object.Name }}SearchSelectorOptions => ({
            searchProjection: searchProjection || { id: true },
            getOptionLabel: (option) => option.{{ LCC $object.Name }}.id,
            enableSearch: true,
            searchDebounceMs: 300,
            clearable: true,
        }),

        // Multiple selection with chips
        multiple: (searchProjection?: {{ UCC $object.Name }}Projection): {{ UCC $object.Name }}SearchSelectorOptions => ({
            multiple: true,
            searchProjection: searchProjection || { id: true },
            getOptionLabel: (option) => option.{{ LCC $object.Name }}.id,
            enableSearch: true,
            clearable: true,
        }),
    };
}

{{- range ListRefFieldObjects $object }}
 {{- if not (eq .Name $object.Name) }}

// {{ UCC .Name }} reference field selector
export type {{ UCC $object.Name }}{{ UCC .Name }}SelectorProps = {
    value?: {{ UCC .Name }} | {{ UCC .Name }}[] | null;
    onChange: (value: {{ UCC .Name }} | {{ UCC .Name }}[] | null) => void;
    multiple?: boolean;
    label?: string;
    placeholder?: string;
    disabled?: boolean;
    getOptionLabel?: (option: {{ UCC .Name }}) => string;
    getOptionDescription?: (option: {{ UCC .Name }}) => string;
};

export function {{ UCC $object.Name }}{{ UCC .Name }}Selector(props: {{ UCC $object.Name }}{{ UCC .Name }}SelectorProps) {
    const {
        value,
        onChange,
        multiple,
        label,
        placeholder,
        disabled,
        getOptionLabel = (option) => option.{{ LCC .Name }}.id,
    } = props;

    const { data: {{ LCC .Name -}}Options, isLoading } = useSearch{{ UCC .Name }}s({
        query: {},
        projection: { id: true },
    });

    return (
        <Autocomplete
            options={ {{- LCC .Name -}}Options?.data || []}
            loading={isLoading}
            multiple={multiple || false}
            disabled={disabled || false}
            value={value}
            onChange={(_, newValue) => onChange(newValue)}
            getOptionLabel={(option) => getOptionLabel(option)}
            isOptionEqualToValue={(option, value) => option.{{ LCC .Name }}.id === value.{{ LCC .Name }}.id}
            renderInput={(params) => (
                <TextField
                    {...params}
                    label={label}
                    placeholder={placeholder}
                    variant="outlined"
                    fullWidth
                />
            )}
        />
    );
}
    {{- end }}
{{- end }}
