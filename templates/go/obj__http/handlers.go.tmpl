{{- $object := .Object }}
{{- $modelPkg := GetModelPackageName $object }}
{{- $apiPkg := GetApiPackageName $object }}

type GetMetadataOnSearchHook func(ctx context.Context, actor permissions.Actor, queryResult    {{ $apiPkg }}.HTTPQueryResult) (map[string]any, error)
type GetMetadataOnCreateHook func(ctx context.Context, actor permissions.Actor, mutationResult {{ $apiPkg }}.HTTPMutationResult) (map[string]any, error)
type GetMetadataOnUpdateHook func(ctx context.Context, actor permissions.Actor, mutationResult {{ $apiPkg }}.HTTPMutationResult) (map[string]any, error)
type GetMetadataOnDeleteHook func(ctx context.Context, actor permissions.Actor, deleteResult   {{ $apiPkg }}.HTTPDeleteResult) (map[string]any, error)

type MetadataHooks struct {
    OnSearch GetMetadataOnSearchHook
    OnCreate GetMetadataOnCreateHook
    OnUpdate GetMetadataOnUpdateHook
    OnDelete GetMetadataOnDeleteHook
}

type HandlerProps struct {
    Api {{ GetApiPackageName $object }}.Client
    ResolveActor func(r *http.Request) (permissions.Actor, error)
    MetadataHooks []MetadataHooks
    OnError func(handler string, e error)
}

func (p *HandlerProps) Validate() error {
    var err error
    if p.Api == nil {
        err = errors.Join(err, errors.New("api is required"))
    }
    if p.ResolveActor == nil {
        err = errors.Join(err, errors.New("resolveActor is required"))
    }
    return err
}

func (p *HandlerProps) onError(endpoint string, e error) {
    if p.OnError != nil {
        p.OnError(endpoint+"<{{ $object.Name }}>", e)
    }
}

{{ if HasHTTPMethod $object "GET" }}
type SearchRequest struct {
    Query {{ $modelPkg }}.HTTPWhereClause `json:"query"`
    Sort {{ $modelPkg }}.HTTPSortParams `json:"sort"`
    Projection *{{ $apiPkg }}.Projection `json:"projection,omitempty"`
    Limit int `json:"limit,omitempty"`
    Skip int `json:"skip,omitempty"`
}

func (sr *SearchRequest) ResolveProjection() *{{ $apiPkg }}.Projection {
    if sr.Projection != nil {
        return sr.Projection
    }
    projection := {{ $apiPkg }}.NewProjection(true)

    {{- range ListToManyRefFields .Object }}
    projection.{{ .Name | UCC | TrimIdSuffix }} = nil
    {{- end }}

    return &projection
}

func GetSearchHandler(props HandlerProps) (http.HandlerFunc, error) {
    if err := props.Validate(); err != nil {
        return nil, err
    }
    return func(w http.ResponseWriter, r *http.Request) {
        searchRequest, err := resolveSearchRequest(r)
        if err != nil {
            http.Error(w, coded_error.ResolveErrorCodeAsString(err), http.StatusBadRequest)
            return
        }

        ctx := r.Context()

        actor, err := props.ResolveActor(r)
        if err != nil {
            props.onError("Search", err)
            log.Debug().Err(err).Msg("failed to resolve actor")
            http.Error(w, coded_error.ResolveErrorCodeAsString(err), coded_error.ResolveHTTPStatus(err))
            return
        }

        if searchRequest.Limit > 1000 {
            props.onError("Search", errors.New("search limit exceeded"))
            log.Debug().Msg("limit exceeded")
            http.Error(w, "MAX_LIMIT_1000", http.StatusBadRequest)
            return
        }

        searchQuery, err := searchRequest.Query.ToWhereClause()
        if err != nil {
            props.onError("Search", err)
            log.Debug().Err(err).Msg("failed to resolve search query")
            http.Error(w, coded_error.ResolveErrorCodeAsString(err), coded_error.ResolveHTTPStatus(err))
            return
        }

        queryResult, projectionResult, err := props.Api.Search(ctx, actor, searchQuery, {{ $apiPkg }}.QueryOptions{
            Projection: searchRequest.ResolveProjection(),
            Sort: searchRequest.Sort.ToSortParams(),
            Limit: searchRequest.Limit,
            Skip: searchRequest.Skip,
        })
        if err != nil {
            props.onError("Search", err)
            log.Debug().Err(err).Msg("failed to execute search query")
            http.Error(w, coded_error.ResolveErrorCodeAsString(err), coded_error.ResolveHTTPStatus(err))
            return
        }

        response, err := {{ $apiPkg }}.ToHTTPQueryResult(queryResult, projectionResult)
        if err != nil {
            props.onError("Search", err)
            log.Debug().Err(err).Msg("failed to convert query result to HTTP response")
            http.Error(w, coded_error.ResolveErrorCodeAsString(err), coded_error.ResolveHTTPStatus(err))
            return
        }

        for i, metadataHook := range props.MetadataHooks {
            if metadataHook.OnSearch != nil {
                metadata, err := metadataHook.OnSearch(ctx, actor, response)
                if err != nil {
                    log.Debug().Err(err).Int("idx", i).Msg("failed to execute metadata hook")
                    http.Error(w, coded_error.ResolveErrorCodeAsString(err), coded_error.ResolveHTTPStatus(err))
                    return
                }
                response.Metadata = metadata
            }
        }

        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusOK)
        err = json.NewEncoder(w).Encode(response)
        if err != nil {
            props.onError("Search", err)
            log.Debug().Err(err).Msg("failed to encode response")
            http.Error(w, coded_error.ResolveErrorCodeAsString(err), http.StatusInternalServerError)
            return
        }
    }, nil
}

type SelectRequest struct {
    Projection *{{ $apiPkg }}.Projection `json:"projection,omitempty"`
}

func (sr *SelectRequest) ResolveProjection() {{ $apiPkg }}.Projection {
    if sr.Projection != nil {
        return *sr.Projection
    }
    return {{ $apiPkg }}.NewProjection(true)
}

func resolveSelectRequest(r *http.Request) (SelectRequest, error) {
    switch r.Method {
        case http.MethodPost:
            selectRequest := SelectRequest{}
            err := json.NewDecoder(r.Body).Decode(&selectRequest)
            if err != nil {
                return SelectRequest{}, coded_error.NewInvalidRequestError()
            }
            return selectRequest, nil
        case http.MethodGet:
            return SelectRequest{}, nil
         default:
            return SelectRequest{}, coded_error.NewMethodNotAllowedError(r.Method)
        }
}

{{- range ListIndexes $object }}
    {{ if .Unique }}
type SelectBy{{ .Name | UCC }}Request struct {
    Query {{ $modelPkg }}.HTTPSelectBy{{ .Name | UCC }}Query `json:"query"`
}

func GetSelectBy{{ .Name | UCC }}Handler(props HandlerProps) (http.HandlerFunc, error) {
    if err := props.Validate(); err != nil {
        return nil, err
    }
    return func(w http.ResponseWriter, r *http.Request) {
        selectRequest, err := resolveSelectRequest(r)
        if err != nil {
            props.onError("SelectBy{{ .Name | UCC }}", err)
            log.Debug().Err(err).Msg("failed to resolve select request")
            http.Error(w, coded_error.ResolveErrorCodeAsString(err), coded_error.ResolveHTTPStatus(err))
            return
        }

        ctx := r.Context()

        actor, err := props.ResolveActor(r)
        if err != nil {
            props.onError("SelectBy{{ .Name | UCC }}", err)
            log.Debug().Err(err).Msg("failed to resolve actor")
            http.Error(w, coded_error.ResolveErrorCodeAsString(err), http.StatusUnauthorized)
            return
        }

        {{ range .Fields }}
        {{ .Name | LCC }} := {{ TransformPathValue $object .Name }}
        if {{ .Name | LCC }} == "" {
            props.onError("SelectBy{{ .Name | UCC }}", errors.New("missing path parameter: {{ .Name }}"))
            log.Debug().Err(err).Msg("missing path parameter")
            http.Error(w, "missing query parameter: {{ .Name }}", http.StatusBadRequest)
            return
        }
        {{ end }}
        selectBy{{ .Name | UCC }}Request := SelectBy{{ .Name | UCC }}Request{
            Query: {{ $modelPkg}}.HTTPSelectBy{{ .Name | UCC }}Query{
            {{- range .Fields }}
            {{ .Name | UCC }}: {{ .Name | LCC }},
            {{- end }}
            },
        }

        selectBy{{ .Name | UCC }}Query, err := selectBy{{ .Name | UCC }}Request.Query.ToSelectBy{{ .Name | UCC }}Query()
        if err != nil {
            props.onError("SelectBy{{ .Name | UCC }}", err)
            log.Debug().Err(err).Msg("failed to resolve select query")
            http.Error(w, coded_error.ResolveErrorCodeAsString(err), coded_error.ResolveHTTPStatus(err))
            return
        }

        projection := selectRequest.ResolveProjection()

        getBy{{ .Name | UCC }}Result, projectionResult, err := props.Api.SelectBy{{ .Name | UCC }}(ctx, actor, selectBy{{ .Name | UCC }}Query, projection)
        if err != nil {
            props.onError("SelectBy{{ .Name | UCC }}", err)
            log.Debug().Err(err).Msg("failed to execute select query")
            http.Error(w, coded_error.ResolveErrorCodeAsString(err), coded_error.ResolveHTTPStatus(err))
            return
        }

        response, err := {{ $apiPkg }}.ToHTTPModel(getBy{{ .Name | UCC }}Result, projectionResult)
        if err != nil {
            props.onError("SelectBy{{ .Name | UCC }}", err)
            log.Debug().Err(err).Msg("failed to convert query result to HTTP response")
            http.Error(w, coded_error.ResolveErrorCodeAsString(err), coded_error.ResolveHTTPStatus(err))
            return
        }

        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusOK)
        err = json.NewEncoder(w).Encode(response)
        if err != nil {
            props.onError("SelectBy{{ .Name | UCC }}", err)
            log.Debug().Err(err).Msg("failed to encode response")
            http.Error(w, coded_error.ResolveErrorCodeAsString(err), coded_error.ResolveHTTPStatus(err))
            return
        }
    }, nil
}
    {{- end }}
{{- end }}

{{ end }}

{{ if or (HasHTTPMethod $object "POST") (HasHTTPMethod $object "PATCH") }}
type SaveRequest struct {
    Data {{ $modelPkg }}.HTTPRecord `json:"data"`
}
{{- end }}

{{ if HasHTTPMethod $object "POST" }}
func GetCreateHandler(props HandlerProps) (http.HandlerFunc, error) {
    if err := props.Validate(); err != nil {
        return nil, err
    }
    return func(w http.ResponseWriter, r *http.Request) {
        if r.Method != http.MethodPost {
            props.onError("Create", errors.New("method not allowed"))
            log.Debug().Msg("method not allowed")
            http.Error(w, "METHOD_NOT_ALLOWED", http.StatusMethodNotAllowed)
            return
        }

        ctx := r.Context()

        actor, err := props.ResolveActor(r)
        if err != nil {
            props.onError("Create", err)
            log.Debug().Err(err).Msg("failed to resolve actor")
            http.Error(w, coded_error.ResolveErrorCodeAsString(err), http.StatusUnauthorized)
            return
        }

        body, err := io.ReadAll(r.Body)
        if err != nil {
            props.onError("Create", err)
            log.Debug().Err(err).Msg("failed to read request body")
            http.Error(w, "INVALID_REQUEST", http.StatusBadRequest)
            return
        }

        projection := {{ $modelPkg }}.NewProjection(true)
        projection.Id = false

        var createRequest SaveRequest
        err = json.Unmarshal(body, &createRequest)
        if err != nil {
            props.onError("Create", err)
            log.Debug().Err(err).Msg("failed to unmarshal request body")
            http.Error(w, "INVALID_REQUEST", http.StatusBadRequest)
            return
        }

        create, err := createRequest.Data.ToModel()
        if err != nil {
            props.onError("Create", err)
            log.Debug().Err(err).Msg("failed to convert request body to model")
            http.Error(w, coded_error.ResolveErrorCodeAsString(err), http.StatusBadRequest)
            return
        }

        createResult, projectionResult, err := props.Api.Create(ctx, actor, create, projection)
        if err != nil {
            props.onError("Create", err)
            log.Debug().Err(err).Msg("failed to execute create query")
            http.Error(w, coded_error.ResolveErrorCodeAsString(err), coded_error.ResolveHTTPStatus(err))
            return
        }

        response, err := {{ $apiPkg }}.ToHTTPMutationResult(createResult, projectionResult)
        if err != nil {
            props.onError("Create", err)
            log.Debug().Err(err).Msg("failed to convert create result to HTTP response")
            http.Error(w, coded_error.ResolveErrorCodeAsString(err), coded_error.ResolveHTTPStatus(err))
            return
        }

        for i, metadataHook := range props.MetadataHooks {
            if metadataHook.OnCreate != nil {
                metadata, err := metadataHook.OnCreate(ctx, actor, response)
                if err != nil {
                    props.onError("Create", err)
                    log.Debug().Err(err).Int("idx", i).Msg("failed to execute metadata hook")
                    http.Error(w, coded_error.ResolveErrorCodeAsString(err), coded_error.ResolveHTTPStatus(err))
                    return
                }
                response.Metadata = metadata
            }
        }

        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusOK)
        err = json.NewEncoder(w).Encode(response)
        if err != nil {
            props.onError("Create", err)
            http.Error(w, coded_error.ResolveErrorCodeAsString(err), coded_error.ResolveHTTPStatus(err))
            return
        }
    }, nil
}
{{ end }}

{{ if HasHTTPMethod $object "PATCH" }}
func GetUpdateHandler(props HandlerProps) (http.HandlerFunc, error) {
    if err := props.Validate(); err != nil {
        return nil, err
    }
    return func(w http.ResponseWriter, r *http.Request) {
        if r.Method != http.MethodPatch {
            props.onError("Update", errors.New("method not allowed"))
            log.Debug().Msg("method not allowed")
            http.Error(w, "METHOD_NOT_ALLOWED", http.StatusMethodNotAllowed)
            return
        }

        ctx := r.Context()

        actor, err := props.ResolveActor(r)
        if err != nil {
            props.onError("Update", err)
            log.Debug().Err(err).Msg("failed to resolve actor")
            http.Error(w, coded_error.ResolveErrorCodeAsString(err), http.StatusUnauthorized)
            return
        }

        body, err := io.ReadAll(r.Body)
        if err != nil {
            props.onError("Update", err)
            log.Debug().Err(err).Msg("failed to read request body")
            http.Error(w, "INVALID_REQUEST", http.StatusBadRequest)
            return
        }

        var updateRequest SaveRequest
        err = json.Unmarshal(body, &updateRequest)
        if err != nil {
            props.onError("Update", err)
            log.Debug().Err(err).Msg("failed to unmarshal request body")
            http.Error(w, "INVALID_REQUEST", http.StatusBadRequest)
            return
        }

        update, err := updateRequest.Data.ToModel()
        if err != nil {
            props.onError("Update", err)
            log.Debug().Err(err).Msg("failed to convert request body to model")
            http.Error(w, coded_error.ResolveErrorCodeAsString(err), http.StatusBadRequest)
            return
        }

        projection, err := updateRequest.Data.ToProjection()
        if err != nil {
            props.onError("Update", err)
            log.Debug().Err(err).Msg("failed to convert request body to projection")
            http.Error(w, coded_error.ResolveErrorCodeAsString(err), http.StatusBadRequest)
            return
        }

        updateResult, projectionResult, err := props.Api.Update(ctx, actor, update, projection)
        if err != nil {
            props.onError("Update", err)
            log.Debug().Err(err).Msg("failed to execute update query")
            http.Error(w, coded_error.ResolveErrorCodeAsString(err), coded_error.ResolveHTTPStatus(err))
            return
        }

        response, err := {{ $apiPkg }}.ToHTTPMutationResult(updateResult, projectionResult)
        if err != nil {
            props.onError("Update", err)
            log.Debug().Err(err).Msg("failed to convert update result to HTTP response")
            http.Error(w, coded_error.ResolveErrorCodeAsString(err), coded_error.ResolveHTTPStatus(err))
            return
        }

        for i, metadataHook := range props.MetadataHooks {
            if metadataHook.OnUpdate != nil {
                metadata, err := metadataHook.OnUpdate(ctx, actor, response)
                if err != nil {
                    props.onError("Update", err)
                    log.Debug().Err(err).Int("idx", i).Msg("failed to execute metadata hook")
                    http.Error(w, coded_error.ResolveErrorCodeAsString(err), coded_error.ResolveHTTPStatus(err))
                    return
                }
                response.Metadata = metadata
            }
        }

        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusOK)
        err = json.NewEncoder(w).Encode(response)
        if err != nil {
            props.onError("Update", err)
            http.Error(w, coded_error.ResolveErrorCodeAsString(err), coded_error.ResolveHTTPStatus(err))
            return
        }
    }, nil
}
{{ end }}

{{ if HasHTTPMethod $object "DELETE" }}
func GetDeleteHandler(props HandlerProps) (http.HandlerFunc, error) {
    if err := props.Validate(); err != nil {
        return nil, err
    }
    return func(w http.ResponseWriter, r *http.Request) {
        if r.Method != http.MethodDelete {
            props.onError("Delete", errors.New("method not allowed"))
            log.Debug().Msg("method not allowed")
            http.Error(w, "method not allowed", http.StatusMethodNotAllowed)
            return
        }

        ctx := r.Context()

        actor, err := props.ResolveActor(r)
        if err != nil {
            props.onError("Delete", err)
            log.Debug().Err(err).Msg("failed to resolve actor")
            http.Error(w, coded_error.ResolveErrorCodeAsString(err), http.StatusUnauthorized)
            return
        }

        id := r.PathValue("id")
        if id == "" {
            props.onError("Delete", errors.New("missing path parameter: id"))
            log.Debug().Msg("missing path parameter")
            http.Error(w, "missing path parameter: id", http.StatusBadRequest)
            return
        }

        err = props.Api.Delete(ctx, actor, id)
        if err != nil {
            props.onError("Delete", err)
            log.Debug().Err(err).Msg("failed to execute delete query")
            http.Error(w, coded_error.ResolveErrorCodeAsString(err), coded_error.ResolveHTTPStatus(err))
            return
        }

        response := {{ $apiPkg }}.ToHTTPDeleteResult(id)

        for i, metadataHook := range props.MetadataHooks {
            if metadataHook.OnDelete != nil {
                metadata, err := metadataHook.OnDelete(ctx, actor, response)
                if err != nil {
                    props.onError("Delete", err)
                    log.Debug().Err(err).Int("idx", i).Msg("failed to execute metadata hook")
                    http.Error(w, coded_error.ResolveErrorCodeAsString(err), coded_error.ResolveHTTPStatus(err))
                    return
                }
                response.Metadata = metadata
            }
        }
        
        w.WriteHeader(http.StatusOK)
        w.Header().Set("Content-Type", "application/json")
        err = json.NewEncoder(w).Encode(response)
        if err != nil {
            props.onError("Delete", err)
            log.Debug().Err(err).Msg("failed to encode response")
            http.Error(w, coded_error.ResolveErrorCodeAsString(err), coded_error.ResolveHTTPStatus(err))
            return
        }
    }, nil
}
{{ end }}

{{ if HasHTTPMethod $object "GET" }}

func resolveSearchRequest(r *http.Request) (SearchRequest, error) {
    switch r.Method {
    case http.MethodPost:
        searchRequest := SearchRequest{
            Limit: 100,
        }
        err := json.NewDecoder(r.Body).Decode(&searchRequest)
        if err != nil {
            return SearchRequest{}, err
        }
        return searchRequest, nil
    case http.MethodGet:
        searchRequest := SearchRequest{
            Query: {{ $modelPkg }}.HTTPWhereClause{},
        }
        for key, values := range r.URL.Query() {
            switch key {
            case "Limit":
                limit := utils.StringSliceToIntPtr(values)
                if limit == nil {
                    return SearchRequest{}, coded_error.NewInvalidRequestError("invalid limit")
                }
                searchRequest.Limit = *limit
                continue
            case "Skip":
                skip := utils.StringSliceToIntPtr(values)
                if skip == nil {
                    return SearchRequest{}, coded_error.NewInvalidRequestError("invalid skip")
                }
                searchRequest.Skip = *skip
                continue
            {{- range ListQueryStringFields $object }}
            case "{{ .Name }}":
                if len(values) == 1 {
                    searchRequest.Query.{{ .Name | UCC }}Eq = utils.StringSliceTo{{ .Type | UCC }}Ptr(values)
                    continue
                }
                if len(values) > 1 {
                    searchRequest.Query.{{ .Name | UCC }}In = utils.StringSliceTo{{ .Type | UCC }}SlicePtr(values)
                    continue
                }
            {{- end }}
            }
        }
        return searchRequest, nil
     default:
        return SearchRequest{}, coded_error.NewMethodNotAllowedError(r.Method)
    }
}

{{ end }}

{{ if HasAggregation $object }}
// HTTPAggregateFieldSpec is the JSON representation of an aggregate field spec
type HTTPAggregateFieldSpec struct {
    Field  string `json:"field"`
    Method string `json:"method"`
    Alias  string `json:"alias,omitempty"`
}

type AggregateRequest struct {
    Query {{ $modelPkg }}.HTTPWhereClause `json:"query"`
    Fields []HTTPAggregateFieldSpec `json:"fields"`
    GroupBy []string `json:"groupBy"`
{{- range ListRefFields $object }}
    {{ .Name | UCC | TrimIdSuffix }}Projection *{{ . | GetRefFieldObj | GetModelPackageName }}.Projection `json:"{{ .Name | LCC | TrimIdSuffix }}Projection,omitempty"`
{{- end }}
}

// AggregateResultRowHTTP is the HTTP response type for a single aggregate result row
type AggregateResultRowHTTP struct {
{{- range $field := ListGroupByFieldDefs $object }}
    {{ $field.Name | UCC }} any `json:"{{ $field.Name | LCC }},omitempty"`
{{- end }}
{{- range ListToOneRefFields $object }}
    // Ref field {{ .Name | UCC | TrimIdSuffix }}
    {{ .Name | UCC | TrimIdSuffix }} any `json:"{{ .Name | LCC | TrimIdSuffix }},omitempty"`
{{- end }}
{{- range ListToManyRefFields $object }}
    // Ref field {{ .Name | UCC }}
    {{ .Name | UCC }} any `json:"{{ .Name | LCC }},omitempty"`
{{- end }}
    // Metadata
    GroupKeys     []string `json:"__groupKeys"`
    AggregateKeys []string `json:"__aggregateKeys"`
}

// AggregateResponseHTTP is the HTTP response type for aggregate results
type AggregateResponseHTTP struct {
    Data  []AggregateResultRowHTTP `json:"data"`
    Total int                      `json:"total"`
}

func GetAggregateHandler(props HandlerProps) (http.HandlerFunc, error) {
    if err := props.Validate(); err != nil {
        return nil, err
    }
    return func(w http.ResponseWriter, r *http.Request) {
        if r.Method != http.MethodPost {
            props.onError("Aggregate", errors.New("method not allowed"))
            log.Debug().Msg("method not allowed")
            http.Error(w, "METHOD_NOT_ALLOWED", http.StatusMethodNotAllowed)
            return
        }

        ctx := r.Context()

        actor, err := props.ResolveActor(r)
        if err != nil {
            props.onError("Aggregate", err)
            log.Debug().Err(err).Msg("failed to resolve actor")
            http.Error(w, coded_error.ResolveErrorCodeAsString(err), http.StatusUnauthorized)
            return
        }

        var aggregateRequest AggregateRequest
        err = json.NewDecoder(r.Body).Decode(&aggregateRequest)
        if err != nil {
            props.onError("Aggregate", err)
            log.Debug().Err(err).Msg("failed to decode request body")
            http.Error(w, "INVALID_REQUEST", http.StatusBadRequest)
            return
        }

        searchQuery, err := aggregateRequest.Query.ToWhereClause()
        if err != nil {
            props.onError("Aggregate", err)
            log.Debug().Err(err).Msg("failed to resolve aggregate query")
            http.Error(w, coded_error.ResolveErrorCodeAsString(err), coded_error.ResolveHTTPStatus(err))
            return
        }

        // Convert HTTP request fields to typed API fields
        apiFields := make([]{{ $apiPkg }}.AggregateFieldSpec, len(aggregateRequest.Fields))
        for i, f := range aggregateRequest.Fields {
            apiFields[i] = {{ $apiPkg }}.AggregateFieldSpec{
                Field:  {{ $apiPkg }}.AggregateField(f.Field),
                Method: {{ $apiPkg }}.AggregateMethod(f.Method),
                Alias:  f.Alias,
            }
        }

        // Convert HTTP request group-by fields to typed API fields
        apiGroupBy := make([]{{ $apiPkg }}.GroupByField, len(aggregateRequest.GroupBy))
        for i, g := range aggregateRequest.GroupBy {
            apiGroupBy[i] = {{ $apiPkg }}.GroupByField(g)
        }

        aggregateResult, err := props.Api.Aggregate(ctx, actor, searchQuery, {{ $apiPkg }}.AggregateOptions{
            Fields: apiFields,
            GroupBy: apiGroupBy,
{{- range ListRefFields $object }}
            {{ .Name | UCC | TrimIdSuffix }}Projection: aggregateRequest.{{ .Name | UCC | TrimIdSuffix }}Projection,
{{- end }}
        })
        if err != nil {
            props.onError("Aggregate", err)
            log.Debug().Err(err).Msg("failed to execute aggregate query")
            http.Error(w, coded_error.ResolveErrorCodeAsString(err), coded_error.ResolveHTTPStatus(err))
            return
        }

        // Convert API result to HTTP response
        httpRows := make([]AggregateResultRowHTTP, len(aggregateResult.Data))
        for i, row := range aggregateResult.Data {
            httpRow := AggregateResultRowHTTP{
                GroupKeys:     row.GroupKeys,
                AggregateKeys: row.AggregateKeys,
            }
            // Copy group-by fields
{{- range $field := ListGroupByFieldDefs $object }}
            httpRow.{{ $field.Name | UCC }} = row.{{ $field.Name | UCC }}
{{- end }}
            // Convert ref fields to HTTP records
{{- range ListToOneRefFields $object }}
            if row.{{ .Name | UCC | TrimIdSuffix }} != nil {
                if aggregateRequest.{{ .Name | UCC | TrimIdSuffix }}Projection != nil {
                    httpRec, _ := row.{{ .Name | UCC | TrimIdSuffix }}.ToHTTPRecord(*aggregateRequest.{{ .Name | UCC | TrimIdSuffix }}Projection)
                    httpRow.{{ .Name | UCC | TrimIdSuffix }} = httpRec
                }
            }
{{- end }}
{{- range ListToManyRefFields $object }}
            if row.{{ .Name | UCC }} != nil && aggregateRequest.{{ .Name | UCC }}Projection != nil {
                httpRecs := make([]any, len(row.{{ .Name | UCC }}))
                for j, rec := range row.{{ .Name | UCC }} {
                    httpRec, _ := rec.ToHTTPRecord(*aggregateRequest.{{ .Name | UCC }}Projection)
                    httpRecs[j] = httpRec
                }
                httpRow.{{ .Name | UCC }} = httpRecs
            }
{{- end }}
            httpRows[i] = httpRow
        }

        httpResponse := AggregateResponseHTTP{
            Data:  httpRows,
            Total: aggregateResult.Total,
        }

        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusOK)
        err = json.NewEncoder(w).Encode(httpResponse)
        if err != nil {
            props.onError("Aggregate", err)
            log.Debug().Err(err).Msg("failed to encode response")
            http.Error(w, coded_error.ResolveErrorCodeAsString(err), http.StatusInternalServerError)
            return
        }
    }, nil
}
{{ end }}
