# Generated Code Reference

[← Back to README](../README.md)

This guide explains the structure and usage of code generated by Forge for Go, TypeScript, and Kotlin.

## Table of Contents

- [Go Backend Structure](#go-backend-structure)
- [Custom Hooks](#custom-hooks)
- [TypeScript Frontend Structure](#typescript-frontend-structure)
- [Kotlin Mobile Structure](#kotlin-mobile-structure)

## Go Backend Structure

The generator creates a comprehensive Go package structure:

```
backend/models/
├── api/                              # Common API interfaces
│   ├── model.go                      # Base model interface
│   └── mongo.go                      # MongoDB interface
│
├── enum_role/                        # Generated enums
│   └── value.go                      # Enum constants and utilities
│
├── permissions/                      # Permission system
│   ├── actor.go                      # Actor interfaces
│   └── super.go                      # Super admin utilities
│
├── permissions_api/                  # Permission API
│   └── fetch_actor.go                # Actor fetching utilities
│
├── http_server/                      # HTTP routing
│   └── routes.go                     # Route registration
│
├── coded_error/                      # Error handling
│   └── error.go                      # Custom error types
│
├── event/                            # Event system
│   └── interface.go                  # Event interfaces
│
├── utils/                            # Utility functions
│   ├── conv.go                       # Conversion utilities
│   └── search.go                     # Search utilities
│
└── user/                            # Example: User model
    ├── model.go                      # Core model struct and methods
    ├── projection.go                 # Field projection utilities
    ├── mongo.go                      # MongoDB integration
    ├── http.go                       # HTTP handler registration
    ├── permissions.go                # Permission implementations
    │
    ├── user_api/                     # API layer
    │   ├── model.go                  # API interface
    │   ├── with_permissions.go       # Permission-wrapped API
    │   ├── unimplemented.go          # Unimplemented stubs
    │   ├── http.go                   # HTTP API implementation
    │   └── mongo.go                  # MongoDB API implementation
    │
    ├── user_mongo/                   # Database layer
    │   ├── collection.go             # Collection and index management
    │   ├── model.go                  # MongoDB record types
    │   ├── lookup.go                 # Lookup operations (with joins)
    │   ├── search.go                 # Search/query operations
    │   ├── save.go                   # Create/update operations
    │   └── delete.go                 # Delete operations
    │
    └── user_http/                    # HTTP layer
        ├── handlers.go               # HTTP request handlers
        └── routes.go                 # Route definitions
```

### Key Generated Files Explained

**`model.go`** - Core model definition:

```go
package user

type Model struct {
    Id        string
    AccountId string
    Email     string
    FirstName string
    LastName  string
    Created   actor_trace.Model
    Updated   actor_trace.Model
}

// Conversion to/from MongoDB records
func (m *Model) ToMongoRecord(projection Projection) (MongoRecord, error)
func (m *Model) FromMongoRecord(r MongoRecord) error
```

**`projection.go`** - Field selection:

```go
type Projection struct {
    Id        bool
    AccountId bool
    Email     bool
    FirstName bool
    LastName  bool
    // ... etc
}

func AllFields() Projection {
    return Projection{
        Id: true,
        AccountId: true,
        // ... all fields true
    }
}
```

**`user_mongo/collection.go`** - Index management:

```go
package user_mongo

const CollectionName = "users"

func CreateIndexes(ctx context.Context, db *mongo.Database) error {
    // Creates all defined indexes
}
```

**`user_mongo/search.go`** - Query operations:

```go
func Search(ctx context.Context, db *mongo.Database, params SearchParams) ([]user.Model, error)
func Count(ctx context.Context, db *mongo.Database, query user_api.UserSearchQuery) (int64, error)
```

**`user_http/handlers.go`** - HTTP handlers:

```go
func GetSearchHandler(props HandlerProps) (http.HandlerFunc, error)
func GetCreateHandler(props HandlerProps) (http.HandlerFunc, error)
func GetUpdateHandler(props HandlerProps) (http.HandlerFunc, error)
func GetDeleteHandler(props HandlerProps) (http.HandlerFunc, error)
```

**`permissions.go`** - Permission checks:

```go
func CanRead(actor permissions.Actor, obj *Model) bool
func CanWrite(actor permissions.Actor, obj *Model) bool
```

## Custom Hooks

The generated API clients support custom hooks that allow you to extend API behavior without modifying generated code. Hooks are passed to `NewMongoBackedClient` when creating the API client and execute at different stages of each operation.

### Hook Types

```go
// Before hooks - modify input before operation executes
type OnBeforeSearchHook func(ctx context.Context, actor permissions.Actor, query user.WhereClause, options QueryOptions) (user.WhereClause, QueryOptions, error)
type OnBeforeCreateHook func(ctx context.Context, actor permissions.Actor, obj user.Model, projection user.Projection) (user.Model, user.Projection, error)
type OnBeforeUpdateHook func(ctx context.Context, actor permissions.Actor, obj user.Model, projection user.Projection) (user.Model, user.Projection, error)
type OnBeforeDeleteHook func(ctx context.Context, actor permissions.Actor, id string) (string, error)

// After hooks - react to operation results (can intercept errors)
type OnSearchHook func(ctx context.Context, actor permissions.Actor, r QueryResult, p Projection, err error) error
type OnCreateHook func(ctx context.Context, actor permissions.Actor, m user.Model, p user.Projection, err error) error
type OnUpdateHook func(ctx context.Context, actor permissions.Actor, m user.Model, p user.Projection, err error) error
type OnDeleteHook func(ctx context.Context, actor permissions.Actor, id string, err error) error

// Hooks struct groups all hook functions
type Hooks struct {
    OnBeforeSearch OnBeforeSearchHook
    OnSearch       OnSearchHook
    OnBeforeCreate OnBeforeCreateHook
    OnCreate       OnCreateHook
    OnBeforeUpdate OnBeforeUpdateHook
    OnUpdate       OnUpdateHook
    OnBeforeDelete OnBeforeDeleteHook
    OnDelete       OnDeleteHook
}
```

### Creating an API Client with Hooks

```go
// Hooks are passed as variadic arguments to NewMongoBackedClient
userApi := user_api.NewMongoBackedClient(db, userHooks...)
accountApi := account_api.NewMongoBackedClient(db, accountHooks...)

// APIs without hooks
telemetryApi := telemetry_api.NewMongoBackedClient(db)
```

### Example: Building Hooks

```go
func GetUserApiHooks(eventApi event_api.Client, natsConn *nats.Conn) []user_api.Hooks {
    return []user_api.Hooks{
        // Validation hooks run first
        {
            OnBeforeCreate: ValidateUserEmail(),
            OnBeforeUpdate: ValidateUserEmail(),
        },
        // Feature flag enforcement
        {
            OnBeforeUpdate: EnsureFeatureFlags(),
            OnBeforeCreate: EnsureFeatureFlags(),
        },
        // Post-operation side effects
        {
            OnCreate: SendWelcomeEmail(emailService),
            OnUpdate: PublishUserChangedEvent(natsConn),
        },
        // Event capture
        {
            OnCreate: CaptureUserCreatedEvent(eventApi),
            OnUpdate: CaptureUserUpdatedEvent(eventApi),
            OnDelete: CaptureUserDeletedEvent(eventApi),
        },
    }
}
```

### Example: Before Hook (Validation/Transformation)

```go
// Before hooks can modify the object and projection before the operation
func EnsureFeatureFlags() user_api.OnBeforeUpdateHook {
    return func(ctx context.Context, actor permissions.Actor, obj user.Model, projection user.Projection) (user.Model, user.Projection, error) {
        // If developer role is being disabled, also disable developer API keys
        if projection.IsDeveloperRoleEnabled {
            if !obj.IsDeveloperRoleEnabled {
                obj.IsDeveloperApiKeysEnabled = false
                projection.IsDeveloperApiKeysEnabled = true
            }
        }
        return obj, projection, nil
    }
}

// Before hooks can also return errors to abort the operation
func ValidateUserEmail() user_api.OnBeforeCreateHook {
    return func(ctx context.Context, actor permissions.Actor, obj user.Model, projection user.Projection) (user.Model, user.Projection, error) {
        if !isValidEmail(obj.Email) {
            return obj, projection, errors.New("INVALID_EMAIL")
        }
        return obj, projection, nil
    }
}
```

### Example: After Hook (Side Effects)

```go
// After hooks receive the result and any error from the operation
func PublishUserChangedEvent(natsConn *nats.Conn) user_api.OnUpdateHook {
    return func(ctx context.Context, actor permissions.Actor, m user.Model, p user.Projection, err error) error {
        if err != nil {
            return err // Pass through errors
        }
        // Publish event after successful update
        event := UserChangedEvent{UserId: m.Id, UpdatedBy: actor.GetId()}
        return natsConn.Publish("user.changed", event)
    }
}

func SendWelcomeEmail(emailService EmailService) user_api.OnCreateHook {
    return func(ctx context.Context, actor permissions.Actor, m user.Model, p user.Projection, err error) error {
        if err != nil {
            return err
        }
        go emailService.SendWelcome(m.Email, m.FirstName)
        return nil
    }
}
```

### Example: Wiring It All Together

```go
func main() {
    db := connectToMongoDB()
    eventApi := event_api.NewMongoBackedClient(db)
    natsConn := connectToNATS()

    // Build hooks
    userHooks := GetUserApiHooks(eventApi, natsConn)
    accountHooks := GetAccountApiHooks(eventApi, natsConn)

    // Create API clients with hooks
    userApi := user_api.NewMongoBackedClient(db, userHooks...)
    accountApi := account_api.NewMongoBackedClient(db, accountHooks...)

    // Use in HTTP handlers
    userRoutes, _ := user_http.RegisterRoutes(user_http.HandlerProps{
        Api:          userApi,
        ResolveActor: resolveActorFromRequest,
    })

    http.ListenAndServe(":8080", userRoutes)
}
```

### Hook Execution Order

1. All `OnBefore*` hooks execute in order (first to last in the slice)
2. The database operation executes
3. All `On*` (after) hooks execute in order (first to last in the slice)

### Common Hook Use Cases

| Hook Type        | Use Cases                                                             |
| ---------------- | --------------------------------------------------------------------- |
| `OnBeforeCreate` | Validation, set default values, enforce business rules, feature flags |
| `OnBeforeUpdate` | Validation, prevent invalid state transitions, enforce constraints    |
| `OnBeforeSearch` | Add mandatory filters, restrict query scope                           |
| `OnBeforeDelete` | Prevent deletion of protected records                                 |
| `OnCreate`       | Send notifications, publish events, initialize related resources      |
| `OnUpdate`       | Sync to external systems, publish change events, invalidate caches    |
| `OnSearch`       | Audit logging, track access patterns                                  |
| `OnDelete`       | Cleanup related data, archive records, publish deletion events        |

### Notes

- Multiple `Hooks` structs can be registered; they execute in slice order
- Before hooks can modify the input and return errors to abort the operation
- After hooks receive the operation result and any error
- After hooks can intercept and transform errors
- Return `nil` from after hooks to allow the operation to complete normally

## TypeScript Frontend Structure

Generated TypeScript files provide complete type safety and API integration:

```
frontend/lib/
├── api/                              # API utilities
│   ├── model.ts                      # Base API client
│   └── errors.ts                     # Error types
│
├── model/                            # TypeScript models
│   ├── user-model.ts                 # User type definitions
│   ├── user-api.ts                   # User API types (queries, filters)
│   ├── role-enum.ts                  # Enum definitions
│   └── ...
│
├── endpoints/                        # API endpoints
│   ├── user-endpoints.ts             # User CRUD functions
│   └── ...
│
├── permissions/                      # Permission utilities
│   ├── actor.ts                      # Actor type
│   ├── user-can-access.ts            # User permission checking
│   └── ...
│
└── react/                           # React integration
    ├── api.tsx                       # API context provider
    │
    ├── tanstack-query/               # React Query hooks
    │   ├── user-queries.ts           # User queries and mutations
    │   └── ...
    │
    ├── form-state/                   # Form management
    │   ├── common.ts                 # Common form utilities
    │   ├── user-form-state.ts        # User form state
    │   └── ...
    │
    └── mui/                          # Material-UI integration
        ├── user-data-grid.ts         # DataGrid configuration
        ├── user-search-selector.ts   # Autocomplete/selector
        └── ...
```

### Key Generated Files Explained

**`model/user-model.ts`** - Type definitions:

```typescript
export type User = {
  id?: string;
  accountId?: string;
  email?: string;
  firstName?: string;
  lastName?: string;
  created?: ActorTrace;
  updated?: ActorTrace;
};

export type UserProjection = {
  id?: boolean;
  accountId?: boolean;
  email?: boolean;
  // ... field flags
};

export type UserSortParams = {
  email?: -1 | 1;
  createdAt?: -1 | 1;
  // ... sortable fields
};
```

**`model/user-api.ts`** - Query and filter types:

```typescript
export type UserSearchQuery = {
  // ID filters
  idEq?: string;
  idIn?: string[];
  idNin?: string[];

  // String field filters
  emailEq?: string;
  emailLike?: string;
  emailExists?: boolean;

  // Ref filters
  accountIdEq?: string;
  accountIdIn?: string[];

  // ... all searchable fields
};

export type UserWithRefs = {
  user: User;
  account?: Account;
  group?: Group;
  // ... related objects
};
```

**`endpoints/user-endpoints.ts`** - API functions:

```typescript
export async function getUser(
  api: ApiContext,
  query: SelectUserByIdQuery,
  projection?: UserProjection
): Promise<User> {
  // GET /users/:id
}

export async function searchUsers(
  api: ApiContext,
  query: UserSearchQuery,
  projection?: UserProjection,
  sort?: UserSortParams,
  limit?: number,
  skip?: number
): Promise<User[]> {
  // GET /users with query params
}

export async function createUser(api: ApiContext, user: User): Promise<User> {
  // POST /users
}

export async function updateUser(
  api: ApiContext,
  id: string,
  updates: Partial<User>
): Promise<User> {
  // PATCH /users/:id
}

export async function deleteUser(api: ApiContext, id: string): Promise<void> {
  // DELETE /users/:id
}
```

**`react/tanstack-query/user-queries.ts`** - React Query hooks:

```typescript
export function useUserQueries() {
  const api = useApi();

  return {
    useGetUser: (query: SelectUserByIdQuery) =>
      useQuery({
        queryKey: ["user", query.id],
        queryFn: () => getUser(api, query),
      }),

    useSearchUsers: (query: UserSearchQuery) =>
      useQuery({
        queryKey: ["users", "search", query],
        queryFn: () => searchUsers(api, query),
      }),

    useCreateUser: () =>
      useMutation({
        mutationFn: (user: User) => createUser(api, user),
        onSuccess: () => {
          queryClient.invalidateQueries({ queryKey: ["users"] });
        },
      }),

    useUpdateUser: () =>
      useMutation({
        mutationFn: ({ id, updates }: { id: string; updates: Partial<User> }) =>
          updateUser(api, id, updates),
        onSuccess: () => {
          queryClient.invalidateQueries({ queryKey: ["users"] });
        },
      }),

    useDeleteUser: () =>
      useMutation({
        mutationFn: (id: string) => deleteUser(api, id),
        onSuccess: () => {
          queryClient.invalidateQueries({ queryKey: ["users"] });
        },
      }),
  };
}
```

**`react/form-state/user-form-state.ts`** - Form state management:

```typescript
export function useUserFormState(initialUser?: User) {
  const [user, setUser] = useState<User>(initialUser || {});
  const [errors, setErrors] = useState<Record<string, string>>({});

  const validate = () => {
    const newErrors: Record<string, string> = {};

    // Generated validation logic
    if (!user.email) {
      newErrors.email = "Email is required";
    } else if (!isValidEmail(user.email)) {
      newErrors.email = "Invalid email format";
    }

    // ... more validation

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  return { user, setUser, errors, validate };
}
```

**`permissions/user-can-access.ts`** - Permission checking:

```typescript
export function canReadUser(actor: Actor, user: User): boolean {
  // Platform admin can read all
  if (actor.roles.includes("PlatformAdmin")) {
    return true;
  }

  // Account owner can read their account's users
  if (
    actor.roles.includes("AccountOwner") &&
    actor.accountId === user.accountId
  ) {
    return true;
  }

  // User can read themselves
  if (actor.id === user.id) {
    return true;
  }

  return false;
}

export function canWriteUser(actor: Actor, user: User): boolean {
  // Similar permission logic for write
}
```

**`mui/user-data-grid.ts`** - Material-UI DataGrid config:

```typescript
export const userDataGridColumns: GridColDef[] = [
  {
    field: "id",
    headerName: "ID",
    width: 200,
  },
  {
    field: "email",
    headerName: "Email",
    width: 200,
  },
  {
    field: "firstName",
    headerName: "First Name",
    width: 150,
  },
  {
    field: "lastName",
    headerName: "Last Name",
    width: 150,
  },
  // ... all fields with appropriate renderers
];
```

## Kotlin Mobile Structure

Generated Kotlin files for mobile applications:

```
mobile/app/src/main/java/com/example/models/
├── User.kt                           # User data class
├── UserApi.kt                        # API client
├── UserPermissions.kt                # Permission checking
├── Role.kt                          # Enum definitions
└── ...
```

**Example Kotlin model:**

```kotlin
@Serializable
data class User(
    val id: String? = null,
    val accountId: String? = null,
    val email: String? = null,
    val firstName: String? = null,
    val lastName: String? = null,
    val created: ActorTrace? = null,
    val updated: ActorTrace? = null
)

@Serializable
data class UserSearchQuery(
    val idEq: String? = null,
    val idIn: List<String>? = null,
    val emailEq: String? = null,
    val emailLike: String? = null,
    // ... filters
)
```
